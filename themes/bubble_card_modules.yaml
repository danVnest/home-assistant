# config copied from sensor.bubble_card_modules for reference
modules:
  home-assistant-default:
    id: home-assistant-default
    name: Home Assistant default styling
    version: v1.7
    creator: Clooos
    supported:
      - button
      - calendar
      - climate
      - cover
      - horizontal-buttons-stack
      - media-player
      - pop-up
      - select
      - separator
    description: >-
      This module applies Home Assistant's default styling to Bubble Card.
      Toggle "All cards" to enable it to all cards, or add <code>is_global:
      true</code> in that module in the <code>bubble-modules.yaml</code> file.
    code: |-
      :host {
          --bubble-main-background-color: var(--ha-card-background, var(--card-background-color, #fff));
          --bubble-border-radius: var(--ha-card-border-radius, 12px);
          --bubble-icon-border-radius: 32px;
          --bubble-button-border-radius: var(--bubble-border-radius);
          --bubble-climate-button-background-color: var(--bubble-icon-background-color);
          --bubble-border: var(--ha-card-border-width, 1px) solid var(--ha-card-border-color, var(--divider-color, #e0e0e0));
          --bubble-secondary-background-color: transparent;
      }

      .bubble-container {
          -webkit-backdrop-filter: var(--ha-card-backdrop-filter, none);
          backdrop-filter: var(--ha-card-backdrop-filter, none);
          box-shadow: var(--ha-card-box-shadow, none);
          box-sizing: border-box;
      }

      .bubble-icon-container, 
      .large .bubble-icon-container {
          --mdc-icon-size: 22px;
          min-width: 36px !important;
          min-height: 36px !important;
      }

      .large .bubble-cover-card-container > .bubble-buttons {
          --bubble-cover-main-background-color: none;
      }

      .bubble-range-fill {
          --bubble-accent-color: var(--bubble-button-accent-color);
      }

      .bubble-sub-button.background-on::before,
      .bubble-sub-button.background-off::before,
      .bubble-temperature-container::before,
      .bubble-icon-container::before {
          content: "";
          position: absolute;
          top: 0; 
          left: 0;
          width: 100%; 
          height: 100%;  
          opacity: var(--control-number-buttons-background-opacity, .2);
          border-radius: var(--bubble-border-radius);
          background: var(--control-number-buttons-background-color, var(--disabled-color));
      }

      .is-on {
          --bubble-icon-background-color: var(--view-background,var(--lovelace-background,var(--primary-background-color)));
          transition: all ease-in 0.3s !important;
      }

      .bubble-icon-container::before {
          background: var(--state-inactive-color);
          border-radius: var(--bubble-icon-border-radius);
      }

      .bubble-sub-button {
          border: 0px solid transparent !important;
      }

      .bubble-select.bubble-wrapper {
          margin: 0 -2px;
      }

      .large .bubble-icon-container {
           margin-left: 9px;
      }

      .bubble-state {
          opacity: 1;
          font-weight: 400;
          font-size: 12px;
          letter-spacing: .4px;
      }

      :not(.bubble-separator) > .bubble-name {
          font-weight: 500;
          font-size: 14px;
          letter-spacing: 0.1px;
      }

      .bubble-pop-up-background { 
          filter: brightness(0.96); /* Improve pop-up background contrast */
          --bubble-pop-up-border-radius: calc(var(--ha-card-border-radius, 12px) * 1.4);
      }

      .bubble-header-container {
          --bubble-secondary-background-color: var(--background-color-2); 
      }

      ha-select {
          --bubble-list-item-accent-color: none !important;
          --mdc-theme-surface: var(--card-background-color);
      }

      mwc-list-item[selected] {
          color: inherit !important;
          --mdc-ripple-press-opacity: 0 !important;
      }

      mwc-list-item[selected]::before {
          content: "";
          position: absolute;
          top: 0; 
          left: 0;
          width: 100%; 
          height: 100%;  
          background-color: var(--primary-color);
          opacity: 0.24;
      }

      .bubble-range-slider,
      .bubble-button-container .bubble-background {
          border-radius: calc(var(--bubble-button-border-radius, var(--bubble-border-radius, calc(var(--row-height,56px)/2))) / 1.1);
      }
    link: https://github.com/Clooos/Bubble-Card/discussions/1230
    is_global: true
  default:
    id: default
    name: Default
    version: ""
    creator: ""
    description: >-
      Empty and enabled by default. Add your custom styles and/or JS templates
      here to apply them to all cards by pressing the <ha-icon
      icon="mdi:pencil"></ha-icon> button above.
    code: |-
      .bubble-main-icon {
        opacity: 1 !important;
      } .bubble-icon-container, .bubble-icon-container::before {
        background: transparent !important;
      } .bubble-state {
        opacity: 0.7 !important;
      }
    supported:
      - button
      - calendar
      - climate
      - cover
      - horizontal-buttons-stack
      - media-player
      - pop-up
      - select
      - separator
    is_global: true
  normalised_sub_button_size:
    id: normalised_sub_button_size
    name: Normalised sub-button size
    version: v1.0
    creator: danVnest
    supported:
      - calendar
      - pop-up
      - cover
      - button
      - media-player
      - climate
      - select
    description: Make sub-buttons the same width and left-justify them.
    code: |
      .bubble-sub-button {
        width: 100%;
        justify-content: left !important;
      }
  icon_border_progress:
    id: icon_border_progress
    name: Icon Border Progress
    version: v1.4.1
    creator: lsmarsden
    link: https://github.com/Clooos/Bubble-Card/discussions/1525
    supported:
      - button
      - climate
      - cover
      - media-player
      - pop-up
      - select
      - separator
    description: |-
      <div><h2>Icon Border Progress</h2>
          <p>
              Forked from <a href="https://github.com/Clooos/Bubble-Card/discussions/1296" target="_blank">Nick's module</a>.

              This module adds the ability to show progress of an entity via icon borders. If using a custom border-radius please make sure you define --bubble-icon-border-radius for this to work correctly.
          </p>

          <p>
              For full documentation including configuration, examples, and more, visit the <a
                  href="https://github.com/lsmarsden/bubble-card-modules/tree/main/modules/icon_border_progress"
                  target="_blank">GitHub repo</a>.
          </p>
      </div>
    code: >-
      ${(() => {

      /**
       * ======== IMPORTED HELPER FUNCTIONS =========
       */

      const getState = (input, fallbackToRaw = true) => {
        if (input == null) return undefined;
        if (typeof input !== "string" && typeof input !== "object") return input;

        let entityId, attribute;

        if (typeof input === "object") {
          entityId = input.entity_id || input.entity;
          attribute = input.attribute || input.att;
        } else {
          // Pattern: entity_id[attribute]
          const match = input.match(/^([A-z0-9_.]+)\[([A-z0-9_]+)]$/);
          if (match) {
            [, entityId, attribute] = match;
          } else if (hass.states[input]) {
            entityId = input;
          } else {
            return fallbackToRaw ? input : undefined;
          }
        }

        const stateObj = hass.states[entityId];
        if (!stateObj) return fallbackToRaw ? input : undefined;

        return attribute ? stateObj.attributes[attribute] : stateObj.state;
      };


      function checkAllConditions(cProp) {
        if (!cProp) return true;
        if (Array.isArray(cProp)) {
          return cProp.every((condition) => evaluateSingleCondition(condition));
        }
        return evaluateSingleCondition(cProp);
      }




      function evaluateSingleCondition(condObj) {
        if (!condObj || typeof condObj !== "object") return false;
        if (!condObj.condition) return false;
        const t = condObj.condition;
        switch (t) {
          case "state": {
            const state = getState(condObj, false);
            if (state === undefined) return false;
            if (Array.isArray(condObj.state)) {
              return condObj.state.includes(state);
            }
            return state === condObj.state;
          }
          case "numeric_state": {
            const numVal = parseFloat(getState(condObj));
            if (isNaN(numVal)) return false;

            const aboveVal = parseFloat(getState(condObj.above));
            if (!isNaN(aboveVal) && numVal <= aboveVal) {
              return false;
            }

            const belowVal = parseFloat(getState(condObj.below));
            if (!isNaN(belowVal) && numVal >= belowVal) {
              return false;
            }

            return true;
          }
          case "exists":
            return getState(condObj) !== undefined;
          case "and":
            if (!Array.isArray(condObj.conditions)) return false;
            return condObj.conditions.every((sc) => evaluateSingleCondition(sc));
          case "or":
            if (!Array.isArray(condObj.conditions)) return false;
            return condObj.conditions.some((sc) => evaluateSingleCondition(sc));
          case "not":
            if (Array.isArray(condObj.conditions) && condObj.conditions.length > 0) {
              return !evaluateSingleCondition(condObj.conditions[0]);
            }
            if (condObj.conditions) {
              return !evaluateSingleCondition(condObj.conditions);
            }
            return false;
          default:
            return false;
        }
      }



      function resolveColor(color, defaultColor) {
        let resolvedColor = getState(color);
        if (!resolvedColor) return defaultColor ?? "var(--primary-color)";
        if (typeof resolvedColor !== "string") return defaultColor ?? "var(--primary-color)";

        resolvedColor = resolvedColor.trim();
        const validPrefixes = ["#", "rgb", "hsl", "var(--"];

        if (validPrefixes.some((prefix) => resolvedColor.startsWith(prefix))) {
          return resolvedColor;
        }

        return `var(--${resolvedColor}-color)`;
      }




      function resolveColorFromStops(progress, stops, interpolate) {
        // handles the situation when HA reformats arrays into objects keyed by numbers.
        if (!Array.isArray(stops) && typeof stops === "object" && stops !== null) {
          stops = Object.values(stops).sort((a, b) => a.percent - b.percent);
        }
        if (!Array.isArray(stops) || !stops || stops.length === 0) {
          return "var(--primary-color)";
        }
        // Sort stops in ascending order by percent
        const sortedStops = stops.slice().sort((a, b) => a.percent - b.percent);

        // Handle out-of-range progress values
        if (progress <= sortedStops[0].percent) {
          return resolveColor(sortedStops[0].color);
        }
        if (progress >= sortedStops[sortedStops.length - 1].percent) {
          return resolveColor(sortedStops[sortedStops.length - 1].color);
        }

        // Find the lower and upper bounds
        const lower = [...sortedStops].reverse().find((s) => s.percent <= progress);
        const upper = sortedStops.find((s) => s.percent >= progress);

        if (!interpolate || resolveColor(lower.color) === resolveColor(upper.color)) {
          return resolveColor(lower.color);
        }

        const range = upper.percent - lower.percent;
        const frac = (progress - lower.percent) / range;
        const format = (v) => parseFloat(v.toFixed(2));

        return `color-mix(in srgb, ${resolveColor(lower.color)} ${format((1 - frac) * 100)}%, ${resolveColor(upper.color)} ${format(frac * 100)}%)`;
      }



      function applyEffects(element, effects) {
        Object.values(effects).forEach((eff) => {
          if (eff.effect) {
            if (checkAllConditions(eff.condition)) {
              element.classList.add(`progress-effect-${eff.effect}`, "has-effect");
            } else {
              element.classList.remove(`progress-effect-${eff.effect}`);
            }
          }
        });
      }



      function toArray(object) {
        if (Array.isArray(object)) return object;
        if (!object || typeof object !== "object") return [];

        return Object.values(object);
      }


      const resolveConfig = (sources, defaultValue = undefined) => {
        for (const source of sources) {
          const keys = Array.isArray(source.path) ? source.path : source.path.split(".");
          const value = getConfigValue(source.config, keys);

          if (value !== undefined && (!source.condition || source.condition(value, source.config))) {
            const metadata = source.metadata || {};
            if (metadata.deprecated) {
              console.warn(
                `[DEPRECATED] Config path "${source.path}" used.` +
                  (metadata.replacedWith ? ` Use "${metadata.replacedWith}" instead.` : "") +
                  (metadata.message ? ` ${metadata.message}` : ""),
              );
            }
            return value;
          }
        }
        return defaultValue;
      };


      function getConfigValue(config, keys) {
        let current = config;
        for (const key of keys) {
          if (current && key in current) {
            current = current[key];
          } else {
            return undefined;
          }
        }
        return current;
      }


      function detectElementShape(element, dimensions, borderRadiusOverride) {
        // Priority: config override > computed CSS > default
        let borderRadiusStyle;

        if (borderRadiusOverride !== undefined && borderRadiusOverride !== null) {
          // Convert number to px string, or use string as-is
          borderRadiusStyle =
            typeof borderRadiusOverride === "number" ? `${borderRadiusOverride}px` : String(borderRadiusOverride);
        } else {
          // Fall back to computed CSS
          borderRadiusStyle = getBorderRadiusStyle(element);
        }

        return detectShapeFromBorderRadius(borderRadiusStyle, dimensions);
      }


      function detectShapeFromBorderRadius(borderRadiusStyle, dimensions) {
        const { width, height } = dimensions;
        let borderRadius = 0;

        if (!borderRadiusStyle) {
          return { isCircular: false, borderRadius: 0 };
        }

        // Parse border radius value to pixels
        if (borderRadiusStyle.includes("%")) {
          const percent = parseInt(borderRadiusStyle) || 0;
          // For percentages, calculate actual pixel value
          // 50% of a 40px element = 20px border radius
          borderRadius = (percent / 100) * Math.min(width, height);
        } else {
          // For pixel values, just parse the number
          borderRadius = parseInt(borderRadiusStyle) || 0;
        }
        const isCircular = width === height && borderRadius >= width / 2;

        return { isCircular, borderRadius };
      }


      function getBorderRadiusStyle(element) {
        if (typeof getComputedStyle === "undefined") {
          return "";
        }

        const computedStyle = getComputedStyle(element);
        return computedStyle.borderRadius || "";
      }


      function createProgressBorder(element, progressValue, progressColor,
      remainingColor, options) {
        const { strokeWidth = 3, animationDuration = 800, borderRadiusOverride, offsetPercent = 0 } = options;
        progressValue = Math.max(0, Math.min(100, progressValue || 0));
        const clampedOffsetPercent = Math.max(0, Math.min(100, offsetPercent));

        let svg = element.querySelector(".stroke-dash-aligned-svg");

        if (!svg) {
          const computedStyle = typeof getComputedStyle !== "undefined" ? getComputedStyle(element) : {};
          if (computedStyle.position === "static") {
            element.style.position = "relative";
          }

          svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          svg.setAttribute("class", "stroke-dash-aligned-svg");
          svg.style.cssText = "position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none";
          element.appendChild(svg);
        }

        const dimensions = getEffectiveDimensions(element);
        svg.setAttribute("viewBox", `0 0 ${dimensions.width} ${dimensions.height}`);
        svg.style.width = `${dimensions.width}px`;
        svg.style.height = `${dimensions.height}px`;

        // Detect shape from border-radius CSS property using helper
        const { isCircular, borderRadius } = detectElementShape(element, dimensions, borderRadiusOverride);

        // Check if SVG needs rebuilding
        const existingPath = svg.querySelector(".progress-path");
        const currentData = `${isCircular}-${borderRadius}-${dimensions.width}-${dimensions.height}`;
        const storedData = svg.getAttribute("data-config");

        if (!existingPath || currentData !== storedData) {
          // Rebuild SVG
          svg.innerHTML = "";
          svg.setAttribute("data-config", currentData);

          // Create path data using actual dimensions
          const { width, height } = dimensions;
          let pathData;

          if (isCircular) {
            // For circles, use the smaller dimension as radius - start at top center
            const radius = (Math.min(width, height) - strokeWidth) / 2;
            const centerX = width / 2;
            pathData = `M ${centerX} ${strokeWidth / 2} A ${radius} ${radius} 0 1 1 ${centerX - 0.01} ${strokeWidth / 2}`;
          } else {
            const r = Math.min(borderRadius, (Math.min(width, height) - strokeWidth) / 2);
            const x = strokeWidth / 2;
            const y = strokeWidth / 2;
            const w = width - strokeWidth;
            const h = height - strokeWidth;

            if (r > 0) {
              // Rounded rectangle - start from top center
              const startX = width / 2;
              pathData = `M ${startX} ${y} 
                          L ${x + w - r} ${y} 
                          Q ${x + w} ${y} ${x + w} ${y + r} 
                          L ${x + w} ${y + h - r} 
                          Q ${x + w} ${y + h} ${x + w - r} ${y + h} 
                          L ${x + r} ${y + h} 
                          Q ${x} ${y + h} ${x} ${y + h - r} 
                          L ${x} ${y + r} 
                          Q ${x} ${y} ${x + r} ${y} 
                          L ${startX} ${y}`;
            } else {
              // Sharp rectangle - start from top center
              const startX = width / 2;
              pathData = `M ${startX} ${y} L ${x + w} ${y} L ${x + w} ${y + h} L ${x} ${y + h} L ${x} ${y} Z`;
            }
          }

          // Create background and progress paths
          ["bg-path", "progress-path"].forEach((className, index) => {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("class", className);
            path.setAttribute("d", pathData);
            path.setAttribute("stroke", index ? "transparent" : remainingColor); // Start progress path as transparent
            path.setAttribute("stroke-width", strokeWidth);
            path.setAttribute("fill", "none");

            if (index) {
              // progress path
              path.setAttribute("stroke-linecap", "round");
              path.style.transition = `all ${animationDuration}ms ease-out`;
            }

            svg.appendChild(path);
          });

          // Calculate path metrics
          const progressPath = svg.querySelector(".progress-path");
          const pathLength = progressPath.getTotalLength ? progressPath.getTotalLength() : 300; // Fallback for environments without getTotalLength

          progressPath.setAttribute("data-length", pathLength);
        }

        // Update progress
        const bgPath = svg.querySelector(".bg-path");
        const progressPath = svg.querySelector(".progress-path");

        bgPath.setAttribute("stroke", remainingColor);

        // Apply progress
        const pathLength = parseFloat(progressPath.getAttribute("data-length"));
        const progressLength = (progressValue / 100) * pathLength;
        const offsetLength = (clampedOffsetPercent / 100) * pathLength;

        // Check if this is the first time setting a non-zero progress value
        const wasTransparent = progressPath.getAttribute("stroke") === "transparent";
        const isFirstPositiveProgress = wasTransparent && progressValue > 0;

        if (progressValue <= 0) {
          // Make progress invisible when 0 or less - keeps transitions working
          progressPath.setAttribute("stroke", "transparent");
          progressPath.setAttribute("stroke-dasharray", `0 ${pathLength}`);
          progressPath.setAttribute("stroke-dashoffset", "0");
        } else {
          // Show progress path with proper color
          progressPath.setAttribute("stroke", progressColor);
          progressPath.setAttribute("stroke-dashoffset", "0"); // Always 0 with new offset approach

          const getDashArray = () => {
            if (progressValue >= 100) {
              return `${pathLength} 0`;
            } else if (progressLength === 0) {
              return `0 ${pathLength}`;
            } else if (offsetLength + progressLength <= pathLength) {
              // No wrap-around needed
              // Pattern: [transparent offset] [progress] [remaining transparent]
              return `0 ${offsetLength} ${progressLength} ${pathLength - offsetLength - progressLength}`;
            } else {
              // Wrap-around needed
              const endProgress = pathLength - offsetLength;
              const wrapProgress = progressLength - endProgress;
              // Pattern: [wrap progress] [gap] [main progress] [remaining]
              return `${wrapProgress} ${offsetLength - wrapProgress} ${endProgress} 0`;
            }
          };

          if (isFirstPositiveProgress) {
            // Start from 0 and animate to target on first appearance
            progressPath.setAttribute("stroke-dasharray", `0 ${offsetLength} 0 ${pathLength - offsetLength}`);
            progressPath.getBoundingClientRect();
            requestAnimationFrame(() => {
              progressPath.setAttribute("stroke-dasharray", getDashArray());
            });
          } else {
            progressPath.setAttribute("stroke-dasharray", getDashArray());
          }
        }
      }




      function getEffectiveDimensions(element) {
        if (!element || !element.getBoundingClientRect) {
          return { width: 38, height: 38 };
        }

        const rect = element.getBoundingClientRect();
        const width = rect.width || 38;
        const height = rect.height || 38;

        return { width, height };
      }




      const getDashArray = () => {
            if (progressValue >= 100) {
              return `${pathLength} 0`;
            } else if (progressLength === 0) {
              return `0 ${pathLength}`;
            } else if (offsetLength + progressLength <= pathLength) {
              // No wrap-around needed
              // Pattern: [transparent offset] [progress] [remaining transparent]
              return `0 ${offsetLength} ${progressLength} ${pathLength - offsetLength - progressLength}`;
            } else {
              // Wrap-around needed
              const endProgress = pathLength - offsetLength;
              const wrapProgress = progressLength - endProgress;
              // Pattern: [wrap progress] [gap] [main progress] [remaining]
              return `${wrapProgress} ${offsetLength - wrapProgress} ${endProgress} 0`;
            }
          };

      function removeProgressBorder(element) {
        const svg = element.querySelector(".stroke-dash-aligned-svg");
        if (svg) {
          svg.remove();
        }
      }


      /**
       * ======== MAIN MODULE CODE =========
       */


        // this allows IDEs to parse the file normally - will be removed automatically during build.
        const { icon_border_progress: config } = this.config;

        function getElementSelector(button) {
          if (button === "main-button" || button === "main") {
            return ".bubble-icon-container";
          } else {
            return `.bubble-${button}`;
          }
        }

        function storeOriginalBackground(element) {
          if (element.dataset.originalBackground === undefined) {
            element.dataset.originalBackground = element.style.background || "";
          }
        }

        function cleanupProgressStyling(element) {
          element.style.background = element.dataset.originalBackground;

          removeProgressBorder(element);
        }

        function calculateProgressValue(progressSource, buttonConfig) {
          let progressValue = parseFloat(getState(progressSource));
          let startValue = parseFloat(getState(buttonConfig.start));
          let endValue = parseFloat(getState(buttonConfig.end));

          startValue = isNaN(startValue) ? 0 : startValue;
          endValue = isNaN(endValue) ? 100 : endValue;

          if (isNaN(progressValue) || progressValue < startValue) {
            progressValue = startValue;
          }
          if (progressValue > endValue) {
            progressValue = endValue;
          }

          return ((progressValue - startValue) / (endValue - startValue)) * 100;
        }

        function resolveColorConfigs(buttonConfig) {
          const remainingColor = resolveConfig([
            { config: buttonConfig, path: "remaining_color" },
            {
              config: buttonConfig,
              path: "remainingcolor",
              metadata: { deprecated: true, replacedWith: "remaining_color" },
            },
          ]);

          const backColor = resolveConfig([
            { config: buttonConfig, path: "background_color" },
            {
              config: buttonConfig,
              path: "backcolor",
              metadata: { deprecated: true, replacedWith: "background_color" },
            },
          ]);

          return {
            remainingProgressColor: resolveColor(remainingColor, "var(--dark-grey-color)"),
            backgroundColor: resolveColor(backColor, "var(--bubble-icon-background-color)"),
            hasBackgroundColor: backColor !== undefined && backColor !== null,
          };
        }

        function applyProgressStyling(element, progressValue, progressColor, colors, buttonConfig) {
          // Only set background if one was configured
          // This allows us to pass-through colours that Bubble Card sets automatically
          // e.g. colours based on the light entity
          if (colors.hasBackgroundColor) {
            element.style.background = `${colors.backgroundColor}`;
          }
          element.style.position = "relative"; // Ensure element can contain absolutely positioned SVG

          createProgressBorder(element, progressValue, progressColor, colors.remainingProgressColor, {
            strokeWidth: 3,
            animationDuration: 800,
            borderRadiusOverride: buttonConfig?.border_radius,
            offsetPercent: buttonConfig?.offset_percent || 0,
          });
        }

        // Main processing loop
        toArray(config).forEach((buttonConfig) => {
          const button = buttonConfig.button;
          if (!button) return;

          const selector = getElementSelector(button);
          const element = card.querySelector(selector);
          if (!element) return;

          storeOriginalBackground(element);

          if (!checkAllConditions(buttonConfig.condition)) {
            cleanupProgressStyling(element);
            return;
          }

          const progressSource = resolveConfig([
            {
              config: buttonConfig,
              path: "source",
            },
            {
              config: buttonConfig,
              path: "entity",
              metadata: { deprecated: true, replacedWith: "source" },
            },
          ]);

          const progressValue = calculateProgressValue(progressSource, buttonConfig);
          const colorStops = buttonConfig.color_stops || [];
          const progressColor = resolveColorFromStops(progressValue, colorStops, buttonConfig.interpolate_colors);
          const colors = resolveColorConfigs(buttonConfig);

          applyProgressStyling(element, progressValue, progressColor, colors, buttonConfig);
          applyEffects(element, buttonConfig.effects || []);
        });
      })()}


      :root {
          --animated-progress-stroke-width: 3;
          --animated-progress-transition-duration: 0.3s;
          --bubble-border-inset: 2px;
      }


      .bubble-icon-container {
          container-type: size;
      }


      .progress-border {
          position: relative;
      }


      .animated-mask-svg {
          position: absolute;
          top: 0;
          left: 0;
          pointer-events: none;

          /* Performance optimizations */
          contain: layout style paint;
          transform: translateZ(0);
          /* Force hardware acceleration */
      }


      .mask-sector {
          fill: black;
          transition: d var(--animated-progress-transition-duration) cubic-bezier(0.4, 0, 0.2, 1);
          will-change: d;
          contain: layout style paint;
      }


      .bg-path,

      .progress-path {
          fill: none;
          stroke-width: var(--animated-progress-stroke-width, 3);
          stroke-linecap: round;
          transition: all var(--animated-progress-transition-duration, 0.3s) cubic-bezier(0.4, 0, 0.2, 1);
          will-change: stroke;
      }
    editor:
      - type: expandable
        title: Dynamic Entity Resolution
        icon: mdi:information-variant-circle-outline
        schema:
          - type: constant
            label: Dynamic Entity Resolution (DER)
            value: >-
              If you see ✨ in an input field, then it supports DER. This allows
              entry of an entity, attribute, or regular value. Just enter the
              entity name. For attributes, use the format ENTITY[ATTRIBUTE],
              e.g., sensor.my_phone[battery_level].
      - type: expandable
        name: "0"
        title: Icon 1 settings (define more in YAML)
        schema:
          - name: button
            label: Button to apply to. Use 'main' or 'sub-button-1' etc.
            selector:
              text: null
          - name: source
            label: ✨Source entity
            selector:
              entity: {}
          - name: condition
            label: >-
              Condition to show progress (see docs for additional condition
              configuration)
            selector:
              condition: {}
          - type: expandable
            label: Custom start/end values (optional)
            schema:
              - type: constant
                value: Use these to override the default 0-100 progress range.
              - name: start
                label: ✨Start value of entity
                selector:
                  number:
                    default: 0
              - name: end
                label: ✨End value of entity
                selector:
                  number:
                    default: 100
          - name: border_radius
            label: Border radius override (e.g., 10 for 10px, or '50%' for circular)
            selector:
              text: null
          - type: expandable
            label: Color settings
            schema:
              - name: interpolate_colors
                label: Gradually transition between colours
                selector:
                  boolean: null
              - type: expandable
                name: color_stops
                label: Progress colors - add more in YAML
                schema:
                  - type: expandable
                    label: Color 1
                    name: "0"
                    schema:
                      - name: color
                        label: ✨Color
                        selector:
                          ui_color: null
                      - name: percent
                        label: From %
                        selector:
                          number:
                            min: 0
                            max: 100
                            step: 1
                            unit_of_measurement: "%"
                  - type: expandable
                    label: Color 2
                    name: "1"
                    schema:
                      - name: color
                        label: ✨Color
                        selector:
                          ui_color: null
                      - name: percent
                        label: From %
                        selector:
                          number:
                            min: 0
                            max: 100
                            step: 1
                            unit_of_measurement: "%"
              - name: background_color
                label: ✨Background colour of icon
                selector:
                  ui_color: null
              - name: remaining_color
                label: ✨Color of remaining progress section
                selector:
                  ui_color: null
      - type: expandable
        name: "1"
        title: Icon 2 settings (define more in YAML)
        schema:
          - name: button
            label: Button to apply to. Use 'main' or 'sub-button-1' etc.
            selector:
              text: null
          - name: source
            label: ✨Source entity
            selector:
              entity: {}
          - name: condition
            label: >-
              Condition to show progress (see docs for additional condition
              configuration)
            selector:
              condition: {}
          - type: expandable
            label: Custom start/end values (optional)
            schema:
              - type: constant
                value: Use these to override the default 0-100 progress range.
              - name: start
                label: ✨Start value of entity
                selector:
                  number:
                    default: 0
              - name: end
                label: ✨End value of entity
                selector:
                  number:
                    default: 100
          - name: border_radius
            label: Border radius override (e.g., 10 for 10px, or '50%' for circular)
            selector:
              text: null
          - type: expandable
            label: Color settings
            schema:
              - name: interpolate_colors
                label: Gradually transition between colours
                selector:
                  boolean: null
              - type: expandable
                name: color_stops
                label: Progress colors - add more in YAML
                schema:
                  - type: expandable
                    label: Color 1
                    name: "0"
                    schema:
                      - name: color
                        label: ✨Color
                        selector:
                          ui_color: null
                      - name: percent
                        label: From %
                        selector:
                          number:
                            min: 0
                            max: 100
                            step: 1
                            unit_of_measurement: "%"
                  - type: expandable
                    label: Color 2
                    name: "1"
                    schema:
                      - name: color
                        label: ✨Color
                        selector:
                          ui_color: null
                      - name: percent
                        label: From %
                        selector:
                          number:
                            min: 0
                            max: 100
                            step: 1
                            unit_of_measurement: "%"
              - name: background_color
                label: ✨Background colour of icon
                selector:
                  ui_color: null
              - name: remaining_color
                label: ✨Color of remaining progress section
                selector:
                  ui_color: null
last_updated: "2025-07-17T01:06:43.204Z"
icon: mdi:puzzle
friendly_name: Bubble Card Modules
